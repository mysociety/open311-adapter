package Open311::Endpoint::Integration::Verint;

use Moo;
use DateTime::Format::W3CDTF;
use Integrations::Verint;
use Digest::MD5 qw(md5_hex);
use Path::Tiny;
use Tie::IxHash;
use URI::Split qw(uri_split);
use Open311::Endpoint::Service::UKCouncil;
use Open311::Endpoint::Service::Request::Update::mySociety;

extends 'Open311::Endpoint';
with 'Open311::Endpoint::Role::mySociety';
with 'Role::EndpointConfig';
with 'Role::Logger';

has jurisdiction_id => ( is => 'ro' );

has integration_class => (
    is => 'ro',
    default => 'Integrations::Verint',
);

has ua => (
    is => 'lazy',
    default => sub {
        LWP::UserAgent->new(agent => "FixMyStreet/open311-adapter")
    },
);

sub get_integration {
    my $self = shift;
    my $integ = $self->integration_class;
    $integ = $integ->on_fault(sub { my($soap, $res) = @_; die ref $res ? $res->faultstring : $soap->transport->status, "\n"; });
    $integ->want_som(1);
    $integ->config_filename($self->jurisdiction_id);
    $self->log_identifier($self->jurisdiction_id);
    return $integ;
}

sub post_service_request {
    my ($self, $service, $args) = @_;

    die "No such service" unless $service;
    my $date = DateTime->now();

    my $services = $self->endpoint_config->{service_whitelist};
    my $service_cfg = $services->{$service->service_code};

    my $integ = $self->get_integration;

    my $address = $args->{attributes}->{closest_address} || '';
    $address =~ s/Nearest road (to the pin placed on the map) (\(automatically generated by OpenStreetMap\))/Nearest address $2 $1/;
    $address =~ s/, London Borough of Enfield, Greater London, England//;
    $address =~ s/, United Kingdom//;

    my $title = $args->{attributes}->{title} . ' - FMS ID: ' . $args->{attributes}->{fixmystreet_id};

    tie my %extra, 'Tie::IxHash';

    if ($service_cfg->{lob_system} eq 'M3') {
        my $comments =
            'Tell us about the problem: ' . $title
            . "\n\nProblem details: " . $args->{attributes}->{description};
        if ($args->{attributes}->{company_name}) {
            $comments .= "\n\nIf applicable, provide the name of the company responsible: " . $args->{attributes}->{company_name};
        }
        $comments .= "\n\nLink: " . $args->{attributes}->{report_url};
        $comments .= "\n\nIssue Location: $address";
        $extra{m3_comments} = $comments;
    } else {
        if ($args->{attributes}->{company_name}) {
            $extra{txt_company_name} = $args->{attributes}->{company_name};
        }
        $extra{txt_map_full_address} = $address;
    }
    if ($service_cfg->{form_name} eq 'lbe_saftey_barrier_new') {
        $extra{dt_date_noticed_problem} = $date->date;
    }
    if ($service_cfg->{form_name} eq 'lbe_illuminated_bollard') {
        $extra{rad_which_sign_problem} = 'Report an unlit illuminated sign';
    }

    if (@{$args->{media_url}}) {
        $extra{txt_sharepoint_link_one} = $args->{media_url}[0];
        $extra{txt_sharepoint_link_two} = $args->{media_url}[1] if $args->{media_url}[1];
    }

    my $result = $integ->CreateRequest(
        $service_cfg->{form_name},
        ixhash(
            # Location
            le_gis_lat => $args->{lat},
            le_gis_lon => $args->{long},
            txt_easting => $args->{attributes}->{easting},
            txt_northing => $args->{attributes}->{northing},
            txt_map_usrn => $args->{attributes}->{usrn},
            txt_map_uprn => $args->{attributes}->{uprn},
            txt_location => $args->{attributes}->{uprn} ? 'Property' : 'Street',
            # Metadata
            txt_request_open_date => $date->datetime . "Z",
            le_typekey => $service_cfg->{typekey},
            txt_service_code => $service_cfg->{service_code},
            txt_lob_system => $service_cfg->{lob_system},
            # Person
            txt_cust_info_first_name => $args->{first_name},
            txt_cust_info_last_name => $args->{last_name},
            eml_cust_info_email => $args->{email},
            tel_cust_info_phone => $args->{phone},
            # Report
            txta_problem_details => $title,
            txta_problem => $args->{attributes}->{description},
            %extra,
        ),
        "Y"
    );
    die "Failed" unless $result;
    $result = $result->method;
    die "Failed" unless $result;
    my $status = $result->{status};
    my $ref = $result->{ref};
    die "$status $ref" unless $status eq 'success';

    $self->update_case_title($ref, $args->{attributes}->{fixmystreet_id});

    return $self->new_request(
        service_request_id => $ref,
    )
}

sub update_case_title {
    my ($self, $ref, $id) = @_;

    my $integ = $self->get_integration;
    my $result = $integ->searchAndRetrieveCaseDetails(
        ixhash(
            'flt:CaseReference' => $ref,
        ),
        'all',
    );
    if ($result) {
        $result = $result->result;
        my $case = $result->{CoreDetails}{CaseReference};
        my $title = $result->{CoreDetails}{Title};
        $title .= " - FMS ID: $id";
        $integ->updateCase($case, $title);
    }
}

sub get_service_request_updates {
    my ($self, $args) = @_;

    my $integ = $self->get_integration;
    my $mapping = $self->endpoint_config->{status_mapping};

    my $result = $integ->searchAndRetrieveCaseDetails(
        ixhash(
            RaisedByUser => { UserID => 'service_fixmystreet' },
            'LastModifiedDateFrom' => $args->{start_date},
            'LastModifiedDateTo' => $args->{end_date},
        ),
        'all',
    );
    return unless $result;
    $result = $result->method;
    return unless $result;

    my $requests = $result->{FWTCaseFullDetails};
    $requests = [ $requests ] unless ref $requests eq 'ARRAY';
    my @updates;
    foreach (@$requests) {
        my $core = $_->{CoreDetails};
        my $closed = $core->{Closed};
        next unless $closed;
        my $reason = $core->{caseCloseureReason};
        my $status = 'closed';
        foreach (keys %$mapping) {
            if ($reason =~ /^$_/) {
                $status = $mapping->{$_};
            }
        }
        my $digest = substr(md5_hex($reason), 0, 8);

        my $refs = $core->{ExternalReferences} or next;
        $refs = $refs->{ExternalReference};

        $refs = [ $refs ] unless ref $refs eq 'ARRAY';
        foreach my $ref (@$refs) {
            $ref =~ s/[^:\w_\-]//g;
            my $update_id = $ref . '_' . $digest;
            push @updates, Open311::Endpoint::Service::Request::Update::mySociety->new(
                status => $status,
                update_id => $update_id,
                service_request_id => $ref,
                description => '',
                updated_datetime => DateTime::Format::W3CDTF->parse_datetime($closed),
                extra => { latest_data_only => 1 },
            );
        }
    }
    return @updates;
}

=head2 services

This returns a list of Verint services from the service_whitelist.

=cut

sub services {
    my $self = shift;

    my $services = $self->endpoint_config->{service_whitelist};

    my @services = map {
        my $cfg = $services->{$_};
        my $name = $cfg->{name};
        my $service = Open311::Endpoint::Service::UKCouncil->new(
            service_name => $name,
            service_code => $_,
            description => $name,
            $cfg->{group} ? (group => $cfg->{group}) : (),
            allow_any_attributes => 1,
        );
        push @{$service->attributes}, Open311::Endpoint::Service::Attribute->new({
            code => 'closest_address',
            description => 'Closest address',
            datatype => 'string',
            automated => 'server_set',
        });
        foreach (@{$cfg->{attributes} || []}) {
            if ($_->{type} eq 'notice') {
                push @{$service->attributes}, Open311::Endpoint::Service::Attribute->new({
                    code => $_->{code},
                    description => $_->{description},
                    variable => 0,
                    datatype => 'string',
                });
            } elsif ($_->{type} eq 'yn') {
                push @{$service->attributes}, Open311::Endpoint::Service::Attribute->new({
                    code => $_->{code},
                    description => $_->{description},
                    datatype => 'singlevaluelist',
                    required => 1,
                    values_sorted => [ 1, 0 ],
                    values => { 0 => 'No', 1 => 'Yes' },
                });
            } elsif ($_->{type} eq 'text') {
                push @{$service->attributes}, Open311::Endpoint::Service::Attribute->new({
                    code => $_->{code},
                    description => $_->{description},
                    datatype => 'string',
                    required => 0,
                });
            }
        }
        $service;
    } sort keys %$services;

    return @services;
}

sub ixhash {
    tie (my %data, 'Tie::IxHash', @_);
    return \%data;
}

1;
