#!/usr/bin/env perl

BEGIN {
    use File::Basename qw(dirname);
    use File::Spec;
    my $d = dirname(File::Spec->rel2abs($0));
    require "$d/../../setenv.pl";
}

package Open311::Endpoint::Integration::UK::Bexley::SymologyCSV;

use Moo;
extends 'Open311::Endpoint::Integration::UK::Bexley::Symology';

has csv_location => (
    is => 'ro'
);

sub _get_update_files {
    my $self = shift;
    return [ $self->csv_location ];
}

1;

package main;

=head1 NAME

bin/bexley/process_update_csv - convert a bexley update csv into FixMyStreet update CSV

=head1 SYNOPSIS

This will take a CSV file as generated by Symology at Bexley and produce a CSV with the
equvalent update values for importing into FixMyStreet.

By default it will parse all rows in the array but you can set a start or end date and any
updates with a date outside those will be ignored.

    # csv files to use
    process_update_csv --infile path/to/symology.csv --outfile path/to/fms.csv

    # set start and end time
    process_update_csv --infile in.csv --outfile out.csv --start_date 2021-04-20T00:00:00Z
    process_update_csv --infile in.csv --outfile out.csv --end_date 2021-04-20T00:00:00Z

    # show this help
    process_update_csv --help

=cut


use Text::CSV;
use DateTime;
use DateTime::Format::W3CDTF;
use Getopt::Long;
use Pod::Usage;
use JSON::MaybeXS;

my ($csv_in, $csv_out, $start_date, $end_date, $csv, $json, $help);

GetOptions (
    'infile=s'  => \$csv_in,
    'outfile=s' => \$csv_out,
    'start_date=s' => \$start_date,
    'end_date=s' => \$end_date,
    'json' => \$json,
    'help|h|?'  => \$help,
);

pod2usage(1) if $help;

my $int = Open311::Endpoint::Integration::UK::Bexley::SymologyCSV->new(
    csv_location => $csv_in
);

my $formatter = DateTime::Format::W3CDTF->new;

$start_date ||= '2010-01-01T00:00:00Z';
unless ( $end_date ) {
    $end_date = $formatter->format_datetime(DateTime->now);
}

my @updates = $int->get_service_request_updates( {
        start_date => $start_date,
        end_date => $end_date,
} );

my $first = pop @updates;


open my $out, '>', $csv_out or die "Failed to open $csv_out: $!\n";

if ( $json ) {
    my @out;

    for my $row(@updates) {
        push @out, {
            description => $row->description,
            update_id => $row->update_id,
            updated_datetime => $formatter->format_datetime($row->updated_datetime),
            status => $row->status,
            service_request_id => $row->service_request_id
        };
    }

    my $json = JSON::MaybeXS->new(utf8 => 1, pretty => 1);
    my $string = $json->encode(\@out);
    print $out $string;
} else {

    my $csv = Text::CSV->new({ binary => 1, eol => "\n" });
    $csv->print($out, [ qw(description update_id time status service_request_id) ]);

    for my $row (@updates) {
        $csv->print($out, [
            $row->description,
            $row->update_id,
            $formatter->format_datetime($row->updated_datetime),
            $row->status,
            $row->service_request_id
        ] );
    }
}

close $out;
